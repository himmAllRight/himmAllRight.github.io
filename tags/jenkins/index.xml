<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jenkins on λ ryan. himmelwright. net</title>
    <link>http://ryan.himmelwright.net/tags/jenkins/</link>
    <description>Recent content in jenkins on λ ryan. himmelwright. net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Aug 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://ryan.himmelwright.net/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Running my Website Tests in Parallel with Pytest-Parallel</title>
      <link>http://ryan.himmelwright.net/post/pytest-parallel-website-tests/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/pytest-parallel-website-tests/</guid>
      <description>&lt;p&gt;Not too long ago, I added some basic testing for my website. Now when I push
changes to my website&amp;rsquo;s source repo, &lt;a href=&#34;../../post/creating-website-tests-ci&#34;&gt;automated
tests&lt;/a&gt; run to verify that the site&amp;rsquo;s &lt;a href=&#34;../../post/creating-website-tests-pages/&#34;&gt;pages
are being served&lt;/a&gt;, and that the (markdown)
&lt;a href=&#34;../../post/creating-website-tests-links&#34;&gt;links are not broken&lt;/a&gt;. It works well
enough through the 450 or so generated tests. However, one recent afternoon I
realized&amp;hellip; I should parallelize them.&lt;/p&gt;

&lt;h2 id=&#34;why-parallelize&#34;&gt;Why Parallelize?&lt;/h2&gt;

&lt;p&gt;Not all tests can be parallelized, but if they &lt;em&gt;can&lt;/em&gt; handle concurrent runs, it
might be worth trying to figure it out.  All of my current website tests do a
single thing: check if a page can be reached, or not. Furthermore, each check
does not interfere with the others. Checking if one link is available does not
change the state of a second one. Ultimately, this means that I could in
theory, run all of the tests at the same time.&lt;/p&gt;

&lt;h2 id=&#34;adding-pytest-parallel&#34;&gt;Adding pytest-parallel&lt;/h2&gt;

&lt;p&gt;It turns out getting my website tests to run in parallel wasn&amp;rsquo;t actually that
hard. I just added a new pip package. I found a few, but the most
promising one seemed to be &lt;code&gt;pytest-parallel&lt;/code&gt;, which simply adds the option to
start pytest runs using parallel workers. To test it out, I installed the package
using the following pip command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;pip install pytest&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;parallel &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;user&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once I verified that it &lt;em&gt;worked&lt;/em&gt;, I updated the &lt;code&gt;Pipfile&lt;/code&gt; in the website test
repo to include the &lt;code&gt;pytest-parallel&lt;/code&gt; package:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;[packages]
pytest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
requests &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
pytest&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;parallel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;rsquo;s it! To run the tests in parallel, just add the &lt;code&gt;--workers&lt;/code&gt; flag with a
number to the &lt;code&gt;pytest&lt;/code&gt; call. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pytest --workers &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; -vv .&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will run my normal test run (&lt;code&gt;pytest -vv .&lt;/code&gt;), across 12 parallel workers.&lt;/p&gt;

&lt;h2 id=&#34;improvements&#34;&gt;Improvements&lt;/h2&gt;

&lt;p&gt;So, did this actually improve anything? Yep, quite a bit ☺.
&lt;center&gt;
&lt;a href=&#34;../../img/posts/pytest-parallel-website-tests/pipeline-time-decrease.png&#34;&gt;
&lt;img alt=&#34;Time decrease in Jenkins test pipline&#34; src=&#34;../../img/posts/pytest-parallel-website-tests/pipeline-time-decrease.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Time decreases in Jenkins Test Pipeline&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Using 12 workers, my test pipeline in Jenkins went from taking around 4.5-5
minutes, all the way down to under 1.5 on average, and sometimes only a minute!
These times include some other steps, but the tests themselves went from
taking a few minutes to under 30 seconds! All 450+ of them!&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s all I have. One day I thought I should parallelize my website tests, and
it turned out to be quite easy to do. Considering the results, I&amp;rsquo;m glad I did.
Again, while it is not always possible to run tests concurrently, if it is for
yours&amp;hellip; try it out!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating Tests For This Website: Docker Jenkins Nodes</title>
      <link>http://ryan.himmelwright.net/post/creating-website-tests-docker-nodes/</link>
      <pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/creating-website-tests-docker-nodes/</guid>
      <description>&lt;p&gt;Okay, quick post! Previously, I wrote about how I &lt;a href=&#34;../../post/creating-website-tests-ci/&#34;&gt;automated my website
tests&lt;/a&gt; using Jenkins. When I wrote that post,
I had the tests run on &lt;code&gt;any&lt;/code&gt; node. I &lt;em&gt;wanted&lt;/em&gt; to have the tests
run inside a fedora docker container, but ran into issues configuring it.
With the problem now long fixed, I decided I would write a quick update post about
switching the pipeline to use container nodes.&lt;/p&gt;

&lt;h3 id=&#34;why-switch&#34;&gt;Why Switch&lt;/h3&gt;

&lt;p&gt;When I first defined the pipeline, I had it use &lt;code&gt;any&lt;/code&gt; node for the agent:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent any

    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// This is where the stages will be defined //
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This just runs the job on any available node, which for me was just the same VM
server I was running Jenkins on. This was fine, but for testing I want to make
sure &lt;em&gt;everything&lt;/em&gt; in my automation is configured and up to date. The best
way to ensure that, is with &lt;em&gt;clean&lt;/em&gt; runs.&lt;/p&gt;

&lt;p&gt;When using docker for the pipeline agent, a new container is created to run the
pipeline in, and then destroyed when completed. This means all packages and
dependencies &lt;em&gt;must&lt;/em&gt; be defined correctly, or the run will fail. This is what we
want.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/docker-quickstart/docker-logo.png&#34;&gt;
&lt;img alt=&#34;Docker Logo&#34; src=&#34;../../img/posts/docker-quickstart/docker-logo.png&#34; style=&#34;float: right; max-width: 100%; width:400px; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-docker-nodes&#34;&gt;Using Docker Nodes&lt;/h3&gt;

&lt;p&gt;First, the obvious: make sure &lt;code&gt;docker&lt;/code&gt; is installed on the desired
Jenkins nodes. I won&amp;rsquo;t cover this as it can be different for
every user (and I already had &lt;code&gt;docker&lt;/code&gt; installed on my Jenkins host).&lt;/p&gt;

&lt;p&gt;With docker installed, next make sure the Jenkins server has the &lt;a href=&#34;https://plugins.jenkins.io/docker-slaves/&#34;&gt;Docker
Slaves&lt;/a&gt; (and possibly &lt;a href=&#34;https://plugins.jenkins.io/docker-workflow/&#34;&gt;Docker
Pipeline&lt;/a&gt;) plug-in(s) installed.&lt;/p&gt;

&lt;p&gt;Lastly, with some docker plug-ins enabled, switch the &lt;code&gt;agent&lt;/code&gt; statement to use a
container image. I choose to use the &lt;code&gt;fedora:31&lt;/code&gt; image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        docker &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            image &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fedora:31&amp;#39;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// rest of the pipeline
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;fixing-root-sudo-error&#34;&gt;Fixing root/sudo error&lt;/h3&gt;

&lt;p&gt;When I first set the pipeline to use the fedora image, it kept failing.
Specifically, the &lt;code&gt;sudo dnf&lt;/code&gt; steps would fail because the &lt;code&gt;sudo&lt;/code&gt; command didn&amp;rsquo;t
exist in the container. If I removed &lt;code&gt;sudo&lt;/code&gt; from the command&amp;hellip;  it still
failed because I didn&amp;rsquo;t have permissions to run &lt;code&gt;dnf&lt;/code&gt; inside the container ಠ_ಠ
(yes, the user was &lt;code&gt;root&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;After some research, I learned that it wasn&amp;rsquo;t passing the root permissions to
the container, and I could &amp;ldquo;solve&amp;rdquo; this issue by providing the &lt;code&gt;-u&lt;/code&gt; flag with
&lt;code&gt;0:0&lt;/code&gt; as an arg to the docker agent:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        docker &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            image &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fedora:31&amp;#39;&lt;/span&gt;
            args &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-u 0:0&amp;#39;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// rest of the pipeline
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I don&amp;rsquo;t &lt;em&gt;love&lt;/em&gt; this solution&amp;hellip; but it seems to work.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Like I said, this was just a quick update about switching my
test nodes to use docker containers. Honestly, I&amp;rsquo;d much rather try to use
&lt;a href=&#34;http://podman.io&#34;&gt;podman&lt;/a&gt; containers for my test agents, but I&amp;rsquo;m sure that
would be much more complicated currently. Maybe in the future&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating Tests For This Website: CI</title>
      <link>http://ryan.himmelwright.net/post/creating-website-tests-ci/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/creating-website-tests-ci/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;../../post/creating-website-tests-pages/&#34;&gt;last post&lt;/a&gt;, I setup some simple
testing for my website builds to that ensure that pages were being served
correctly.  However, I can&amp;rsquo;t trust myself to always manually run the tests
before merging a branch into &lt;code&gt;master&lt;/code&gt;. Luckily, I have
&lt;a href=&#34;https://jenkins.io&#34;&gt;Jenkins&lt;/a&gt; to take care of all the &amp;ldquo;&lt;em&gt;responsible&lt;/em&gt;&amp;rdquo; tasks. In
this post, we will take the test framework created in the previous post&amp;hellip;  and
automate it.&lt;/p&gt;

&lt;h2 id=&#34;what-i-m-using-plan&#34;&gt;What I&amp;rsquo;m Using/Plan&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/jenkins-logo.png&#34;&gt;
&lt;img alt=&#34;Jenkins Logo&#34; src=&#34;../../img/posts/creating-website-tests-ci/jenkins-logo.png&#34; style=&#34;float: right; max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;I have started using &lt;a href=&#34;https://gitlab.com&#34;&gt;Gitlab&lt;/a&gt; for more of my projects
recently, but have decided to keep my website source hosted on Github for the time
being. So, I won&amp;rsquo;t be using Gitlab&amp;rsquo;s CI/CD tools for &lt;em&gt;this&lt;/em&gt;, but I wanted it
to be known that this automation is &lt;em&gt;very&lt;/em&gt; straight forward and could be easily
accomplished there as well.&lt;/p&gt;

&lt;p&gt;For this project, because my website is hosted on Github, and I &lt;em&gt;already&lt;/em&gt;
have &lt;a href=&#34;../../post/extending-vm-hd/&#34;&gt;my own Jenkins server&lt;/a&gt; configured&amp;hellip; I will be
using a Jenkins pipeline. First, we will create the pipeline file to add
to the git repo. Then, we will use the pipeline to configure a new
&lt;em&gt;multi-branch&lt;/em&gt; pipeline in Jenkins.&lt;/p&gt;

&lt;h2 id=&#34;jenkinsfile&#34;&gt;Jenkinsfile&lt;/h2&gt;

&lt;p&gt;Lets start by creating the Jenkinsfile. Create a new file named &lt;code&gt;Jenkinsfile&lt;/code&gt;
in the project directory. Next, lets create a new pipeline and get ready to add
stages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent any

    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// This is where the stages will be defined //
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;(Make sure to add the closing &lt;code&gt;}&lt;/code&gt;&amp;rsquo;s!)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;stages&#34;&gt;Stages&lt;/h3&gt;

&lt;p&gt;Now, lets add the stages. A stage is a named, functional chunk in our pipeline.
Breaking the pipeline into stages will help keep all the various steps
organized, as well as make it easier to follow along as the pipeline runs.&lt;/p&gt;

&lt;p&gt;Each of the following stage definitions will be placed inside the &lt;code&gt;stages { ..
}&lt;/code&gt; section we defined above (&lt;em&gt;in the same order as they are listed!&lt;/em&gt;).&lt;/p&gt;

&lt;h4 id=&#34;setup-deps&#34;&gt;Setup Deps&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Setup Deps&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum update -y&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum install -y epel-release&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum install -y hugo python36-pytest&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first stage is &amp;lsquo;Setup Deps&amp;rsquo;. This stage handles installing any dependencies
our Jenkins node will need installed to run the tests. Our tests will require
&lt;code&gt;hugo&lt;/code&gt;, &lt;code&gt;pytest&lt;/code&gt;, and &lt;code&gt;python3&lt;/code&gt;. It will also require some &lt;code&gt;pip&lt;/code&gt; packages, but
we will get to that later.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: My current Jenkins node is running CentOS, so my package manager commands
are specific to that. As always, adjust accordingly.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;start-hugo-server&#34;&gt;Start Hugo Server&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Start Hugo Server&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hugo serve &amp;amp;&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;hugo&lt;/code&gt; installed (and presumably being inside the website&amp;rsquo;s git repo&amp;hellip;),
we can start the web server. This is done with &lt;code&gt;hugo serve&lt;/code&gt;. The &lt;code&gt;&amp;amp;&lt;/code&gt; is used to
have the server run as a background process so that it won&amp;rsquo;t be killed when the
pipeline to continues on.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Make sure the tests are set to point to &lt;code&gt;localhost:1313&lt;/code&gt;, as that is
where &lt;code&gt;hugo&lt;/code&gt; will try to serve the website by default.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;setup-python&#34;&gt;Setup Python&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Setup Tests&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pip3 install pipenv --user&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;python3 -m pipenv install&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, lets configure &lt;code&gt;python&lt;/code&gt; by setting up an environment and installing the
packages we need in it. First, I use &lt;code&gt;pip3&lt;/code&gt; to install &lt;code&gt;pipenv&lt;/code&gt;. Then, I have
&lt;code&gt;pipenv&lt;/code&gt; install the tests&amp;rsquo; required python packages, which are defined in the
repo&amp;rsquo;s &lt;code&gt;Pipfile&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;run-tests&#34;&gt;Run Tests&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Run Tests&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            set +e
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            python3 -m pipenv run pytest -v --junit-xml himmallright-source-test-report.xml .
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            set -e
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stripIndent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Test time. I again utilize &lt;code&gt;pipenv&lt;/code&gt; here, by having it call the test command
(&lt;code&gt;pytest -v --junit-xml himmallright-source-test-report.xml .&lt;/code&gt;) so that it runs
in the pipenv virtual environment.&lt;/p&gt;

&lt;p&gt;Two things to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;--junit-xml&lt;/code&gt; flag defines a xml filename to write the junit test report
to. This will be used by Jenkins to collect the test results.&lt;/li&gt;
&lt;li&gt;The test command is wrapped between &lt;code&gt;set +e&lt;/code&gt; and &lt;code&gt;set -e&lt;/code&gt; commands, which
allows tests to fail but without triggering a &lt;em&gt;pipeline&lt;/em&gt; failure in
Jenkins.  This way even if tests fail, we make it all the way through
collection so we can see &lt;em&gt;what&lt;/em&gt; tests failed and &lt;em&gt;why&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;collect-test-results&#34;&gt;Collect Test Results&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Collect Test Resuts&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        archiveArtifacts &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;himmallright-source-test-report.xml&amp;#34;&lt;/span&gt;
        junit &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;himmallright-source-test-report.xml&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, we archive the junit report xml file as a Jenkins artifact (just in
case). Finally, we have the &lt;a href=&#34;https://plugins.jenkins.io/junit/&#34;&gt;junit&lt;/a&gt; plugin
collect the report.&lt;/p&gt;

&lt;h3 id=&#34;save-commit&#34;&gt;Save &amp;amp; Commit&lt;/h3&gt;

&lt;p&gt;That should be it for the pipeline file! Commit and push it to the git repo,
and we can start working with it in Jenkins!&lt;/p&gt;

&lt;h2 id=&#34;multibranch-pipelines&#34;&gt;Multibranch Pipelines&lt;/h2&gt;

&lt;p&gt;With the &lt;code&gt;Jenkinsfile&lt;/code&gt; in the repo, we can create the pipeline! Specifically,
we will be creating a mult-branch pipeline. A &lt;em&gt;multi-branch&lt;/em&gt; job scans a git
project, and creates a separate pipeline for each branch or PR in the repo.
This is beneficial for testing, as it will automatically instantiate a test
pipeline against a newly created PR, so we can verify that the PR passes the
tests before merging it into the &lt;code&gt;master&lt;/code&gt; branch. Additionally, it lets us make
sure we aren&amp;rsquo;t breaking anything &lt;em&gt;while&lt;/em&gt; working in a new branch.&lt;/p&gt;

&lt;h4 id=&#34;creating-the-pipeline&#34;&gt;Creating the Pipeline&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/new-job.png&#34;&gt;
&lt;img alt=&#34;Creating a new Jenkins Item&#34; src=&#34;../../img/posts/creating-website-tests-ci/new-job.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Select Multibranch Pipeline from the new item menu in Jenkins.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To create a Multi-Branch pipeline, select &lt;em&gt;New Item&lt;/em&gt; in the menu on the left.
Next, enter a name for the pipeline and select &lt;em&gt;Multibranch Pipeline&lt;/em&gt; at the
bottom. Click &lt;em&gt;Ok&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;configuring-the-pipeline&#34;&gt;Configuring the Pipeline&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/multipipeline-config-options.png&#34;&gt;
&lt;img alt=&#34;Multibranch pipeline config options&#34; src=&#34;../../img/posts/creating-website-tests-ci/multipipeline-config-options.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Configuration options when creating the multibranch
pipeline.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;On the pipelines configuration page, start by filling out the &lt;em&gt;Display Name&lt;/em&gt;
and &lt;em&gt;Description&lt;/em&gt; text boxes. Next, go down to &lt;em&gt;Branch Sources&lt;/em&gt; and click on
&lt;em&gt;Add source&lt;/em&gt;. My website is currently hosted on Github, so I will select that.
However, select &lt;em&gt;Git&lt;/em&gt; if your project is hosted on another &lt;code&gt;git&lt;/code&gt; service.&lt;/p&gt;

&lt;p&gt;Add the Repository URL and choose the pipeline Behaviors. The Behaviors define
how the pipeline will split up branches. For example, it can be selected to
only discover branches that are also PRs.&lt;/p&gt;

&lt;p&gt;Next, in the &lt;em&gt;Build Configuration&lt;/em&gt; section, be sure that the &lt;em&gt;Script Path&lt;/em&gt;
defines the path where the &lt;code&gt;Jenkinsfile&lt;/code&gt; is located. If it&amp;rsquo;s in the root
directory (and named &lt;code&gt;Jenkinsfile&lt;/code&gt;), the default should work.&lt;/p&gt;

&lt;p&gt;Lastly, select an interval to automatically check the repo for changes in the
&lt;em&gt;Scan Repository Triggers&lt;/em&gt; section. This step is optional, but I highly
recommend it.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all we &lt;em&gt;need&lt;/em&gt; to setup, but feel free to research more options. I mostly
have defaults selected for the rest. When complete, hit &lt;em&gt;Save&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;running-pipelines&#34;&gt;Running Pipelines&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/multibranch-pipeline-overview.png&#34;&gt;
&lt;img alt=&#34;The multibranch pipeline overview page&#34; src=&#34;../../img/posts/creating-website-tests-ci/multibranch-pipeline-overview.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The multibranch pipeline overview page.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Once the multibranch pipeline is created, it should scan the repo to detect any
branches or pull requests that have defined &lt;code&gt;Jenkinsfile&lt;/code&gt;s. It will create an
job item in the list for each branch/PR it detects (and kick off runs for
each).&lt;/p&gt;

&lt;p&gt;To manually start a scan, select &lt;em&gt;Scan Repository Now&lt;/em&gt; in the menu on the left,
and it will scan all the branches again, looking for changes, and kicking off
pipeline runs for any branch or pr that has changed.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/branch-overview.png&#34;&gt;
&lt;img alt=&#34;The overview page of a single branch&#34; src=&#34;../../img/posts/creating-website-tests-ci/branch-overview.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The overview page of a single branch.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To manually start a specific branch run, click on the branch name to enter the
branch&amp;rsquo;s job overview page. Then, simply click &lt;em&gt;Build Now&lt;/em&gt; on the left. Once
the run starts, it runs like a normal jenkins job and can be viewed by clicking
the job&amp;rsquo;s run number to the bottom left. The job&amp;rsquo;s progress can then be viewed
on that page, or using &lt;em&gt;Blue Ocean&lt;/em&gt; (Recommended).&lt;/p&gt;

&lt;h2 id=&#34;viewing-results&#34;&gt;Viewing Results&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/test-results.png&#34;&gt;
&lt;img alt=&#34;The overview page of a single branch&#34; src=&#34;../../img/posts/creating-website-tests-ci/test-results.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The overview page of a single branch.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Personally, I prefer to always view the test results using the Blue Ocean
viewer. Once a job completes, select the &lt;em&gt;Tests&lt;/em&gt; tab at the top of the viewer
to see the collected test results (this is what the junit steps in our pipeline
does). If all the tests passed, the page will be green and list all the
completed tests. If some failed, it will be yellow. When there are failed
tests, they can be clicked, and the row will expand to show the failed test&amp;rsquo;s
error message and stack trace. For my test set, this makes it easy to see which
page failed, and even know what status code was &lt;em&gt;actually&lt;/em&gt; returned in the
response (by looking at the stack trace). Very helpful!&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There we go! Not only do we now have the website tests automated as a pipeline,
but as a &lt;em&gt;multibranch&lt;/em&gt; pipeline. This should help automatically ensure that
nothing breaks as I edit and add to the website. It will even run the tests
against all my PRs, so I can be confident that when I merge to master, it won&amp;rsquo;t
slowly degrade my website over time. I have one more post about these tests
planned, but in the meantime&amp;hellip; enjoy Jenkins!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Extending a VM Virtual Disk</title>
      <link>http://ryan.himmelwright.net/post/extending-vm-hd/</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/extending-vm-hd/</guid>
      <description>&lt;p&gt;Last week, I extended the virtual disk of the VM hosting my
&lt;a href=&#34;https://jenkins.io&#34;&gt;jenkins&lt;/a&gt; server. Shortly after, I increased the maximum
disk size of one of the job&amp;rsquo;s docker containers, maxing out the disk. This
meant that I needed to extend the drive&lt;em&gt;&amp;hellip; again&lt;/em&gt;. If you ever do something
twice, it is &lt;em&gt;best&lt;/em&gt; to have it documented for the potential third time. So,
here we are.&lt;/p&gt;

&lt;h4 id=&#34;assumptions&#34;&gt;Assumptions&lt;/h4&gt;

&lt;p&gt;Before getting started, I want to point out that this method is specific to the
environment I currently have for &lt;em&gt;my VMs&lt;/em&gt;. Specifically, I am using kvm/qemu
and virt-manager, with qcow2 images for the virtual disks. Additionally, the
specific VM I was extending was installed with LVM and it&amp;rsquo;s main partition was
formatted with a xfs file system. Just note that some steps &lt;em&gt;may&lt;/em&gt; differ
elsewhere. This is what worked for &lt;em&gt;me&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;clone-vm&#34;&gt;Clone VM&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/extending-vm-hd/clone-vm.png&#34;&gt;&lt;img alt=&#34;Clone VM window in Virt Manager&#34; src= &#34;/img/posts/extending-vm-hd/clone-vm.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Cloning the VM in Virt Manager&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;While not &lt;em&gt;required&lt;/em&gt;, it isn&amp;rsquo;t a &lt;em&gt;bad&lt;/em&gt; idea to first clone the VM (just
in case anything becomes damaged). If using &lt;code&gt;virt-manager&lt;/code&gt;, cloning a
VM is as simple as right clicking a &lt;em&gt;powered down&lt;/em&gt; VM, and selecting
&amp;ldquo;&lt;em&gt;Clone&amp;hellip;&lt;/em&gt;&amp;rdquo;. A window will pop up with options for cloning the
VM. Make the desired name changes and hit &lt;em&gt;Clone&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;extend-qcow2-file&#34;&gt;Extend qcow2 file&lt;/h2&gt;

&lt;p&gt;The first step in resizing the virtual drive is to first expand
the &lt;code&gt;qcow2&lt;/code&gt; image. By default, the images tend to be stored at
&lt;code&gt;/var/lib/libvirt/images/&lt;/code&gt; and will require &lt;code&gt;root&lt;/code&gt; privileges to
access. Virt-Manager can be used to double check which image the VM is
using for its disk. To resize the qcow2 image, use the &lt;code&gt;qemu-img
resize&lt;/code&gt; command, providing it the image file path/name and then the size
to expand it. For example, I used &lt;code&gt;+40G&lt;/code&gt; in my command (&lt;code&gt;qemu-img
resize Jenkins.qcow2 +40G&lt;/code&gt;) to extend the image by 40GB.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@ninetales:/var/lib/libvirt/images# qemu-img info Jenkins.qcow2
image: Jenkins.qcow2
file format: qcow2
virtual size: 20G &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;21474836480&lt;/span&gt; bytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
disk size: 20G
cluster_size: &lt;span style=&#34;color:#ae81ff&#34;&gt;65536&lt;/span&gt;
Format specific information:
    compat: 1.1
    lazy refcounts: true
    refcount bits: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;
    corrupt: false

root@ninetales:/var/lib/libvirt/images# qemu-img resize Jenkins.qcow2 +40G
Image resized.

root@ninetales:/var/lib/libvirt/images# qemu-img info Jenkins.qcow2
image: Jenkins.qcow2
file format: qcow2
virtual size: 60G &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;64424509440&lt;/span&gt; bytes&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
disk size: 20G
cluster_size: &lt;span style=&#34;color:#ae81ff&#34;&gt;65536&lt;/span&gt;
Format specific information:
    compat: 1.1
    lazy refcounts: true
    refcount bits: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;
    corrupt: false

root@ninetales:/var/lib/libvirt/images#&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The command &lt;code&gt;qemu-image info&lt;/code&gt; can be helpful in verifying that the resize
worked, by checking the size of the image.&lt;/p&gt;

&lt;h2 id=&#34;gparted-live-iso&#34;&gt;Gparted Live ISO&lt;/h2&gt;

&lt;p&gt;For the next few steps, it is a good idea to boot the system from a live CD.
This will run the OS in RAM, allowing the disk to be fully unmounted.  With
access to the VM&amp;rsquo;s display, an ISO such as the &lt;a href=&#34;https://gparted.org/livecd.php&#34;&gt;gparted live
CD&lt;/a&gt; can be used to resize the partitions,
as it contains the amazing graphical tool, &lt;code&gt;gparted&lt;/code&gt; (duh).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you boot up the VM and don&amp;rsquo;t see the new unallocated space available in the
volume&amp;hellip; make sure you didn&amp;rsquo;t accidentally boot the &lt;em&gt;backup VM&lt;/em&gt;&amp;hellip; Not that
&lt;strong&gt;I made such a mistake&amp;hellip;&lt;/strong&gt; :P&lt;/p&gt;

&lt;h4 id=&#34;lvm-resize&#34;&gt;LVM Resize&lt;/h4&gt;

&lt;p&gt;My VM is installed using LVM volumes, so I had to resize them
before I could resize the file system. Gparted will do this
automatically when resizing a partition.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/extending-vm-hd/gparted-live-iso.png&#34;&gt;&lt;img alt=&#34;Booting into the Gparted live ISO&#34; src= &#34;/img/posts/extending-vm-hd/gparted-live-iso.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Booting into the Gparted live ISO&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To resize the partition, first verify that the correct virtual disk
is selected in the top right drop-down the window. Next, select the
partition to expand, and click the &amp;ldquo;&lt;em&gt;Resize/Move&lt;/em&gt;&amp;rdquo; icon at the top.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/extending-vm-hd/gparted-resize.png&#34;&gt;&lt;img alt=&#34;Resizing the partition in Gparted&#34; src= &#34;/img/posts/extending-vm-hd/gparted-resize.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Resizing the partition in Gparted&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;In the resize window, I changed the &lt;code&gt;Free space following (MiB)&lt;/code&gt;
value to &lt;code&gt;0&lt;/code&gt;, to expand the partition to use &lt;em&gt;all&lt;/em&gt; of the unallocated space.
Lastly, I hit the &lt;em&gt;Resize&lt;/em&gt; button and let Gparted do it&amp;rsquo;s magic.&lt;/p&gt;

&lt;h4 id=&#34;grow-xfs&#34;&gt;Grow XFS&lt;/h4&gt;

&lt;p&gt;Finally, with the lvm volume expanded, I just had to grow my file system to use
the new space. I booted up the VM and logged in. This VM uses an xfs file
system, so I was able to use the &lt;code&gt;xfs_growfs&lt;/code&gt; command to expand the partition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ryan@mr-mime ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;$ sudo xfs_growfs /dev/centos/root
&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;... Ryan removed output &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; the post...&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
data blocks changed from &lt;span style=&#34;color:#ae81ff&#34;&gt;4851712&lt;/span&gt; to &lt;span style=&#34;color:#ae81ff&#34;&gt;15322112&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ryan@mr-mime ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;$ df -h
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   59G   19G   40G  32% /
devtmpfs                 1.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  1.9G   0% /dev
tmpfs                    1.9G  8.0K  1.9G   1% /dev/shm
tmpfs                    1.9G  8.7M  1.9G   1% /run
tmpfs                    1.9G     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  1.9G   0% /sys/fs/cgroup
/dev/vda1                497M  231M  267M  47% /boot
tmpfs                    379M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  379M   0% /run/user/1000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: My VM&amp;rsquo;s disk space was COMPLETELY full. This meant that I couldn&amp;rsquo;t use auto
tab complete in my shell because it spit out there&amp;rsquo;s no disk space. Typing the
command out fully by hand, still worked.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With the xfs partition resized, I rebooted the VM for good measure, and
everything was up and running again.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s about it. Remember, the steps I took might need to be altered for other
environments, but this post should still be a good &lt;em&gt;starting&lt;/em&gt; point. I know it
will help me when I acidently overfill this VM &lt;em&gt;again&lt;/em&gt;&amp;hellip; Enjoy!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating a CI/CD &#39;Draft&#39; Website with Jenkins (and Hugo)</title>
      <link>http://ryan.himmelwright.net/post/draft-website-with-jenkins/</link>
      <pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/draft-website-with-jenkins/</guid>
      <description>&lt;p&gt;The last few months I have been working more with the open source
automation server, &lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt;. While digging into
it, I have been thinking of ways to improve my home build
environment. One idea, was to utilize Jenkins to automatically build
and deploy a &amp;ldquo;draft&amp;rdquo; website, so I can stage new posts/website change
on my home network, before publishing it to the &amp;ldquo;production&amp;rdquo;
website. Here is how that idea was Instantiated&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;my-website&#34;&gt;My Website&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;../../img/posts/draft-website-jenkins/jenkins-logo.png&#34;&gt;&lt;img
src=&#34;../../img/posts/draft-website-jenkins/jenkins-logo.png&#34; style=&#34;max-width:
50%; float: left; margin: 0px 12px 0px 0px;&#34; alt=&#34;Jenkins Logo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I have previously &lt;a href=&#34;../../post/website-transition-to-hugo/&#34;&gt;described&lt;/a&gt; how my
website is &lt;a href=&#34;../../post/website-switched-to-hugo/&#34;&gt;currently generated&lt;/a&gt;, using
the &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; static website generator. To organize
this system, I have two git repos: One that consists of all the hugo
source files (where I write content), and one that contains the
generated static website (that gets deployed to my web host).&lt;/p&gt;

&lt;p&gt;When writing a post, I use &lt;code&gt;hugo server -D -F&lt;/code&gt; to live view the page
in my browser. However, I occasionally want to view the state of all
the &lt;em&gt;committed code&lt;/em&gt; in the &lt;em&gt;repo&lt;/em&gt;, to see what the site would look
like if I decided to publish a post. So, I created a &amp;ldquo;drafts&amp;rdquo; website,
which shows the current state of my website&amp;rsquo;s &lt;em&gt;source&lt;/em&gt; repo (including
draft and future posts). If I want to check how a post looks on my
phone, or any other device, I can just open up the draft website after
pushing my changes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../../img/posts/draft-website-jenkins/mr-mime.png&#34;&gt;&lt;img
src=&#34;../../img/posts/draft-website-jenkins/mr-mime.png&#34; style=&#34;max-width:
45%; float: right; margin: 20px 0px 0px 10px;&#34; alt=&#34;Jenkins Logo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h2&gt;

&lt;p&gt;I had previously created a dedicated Jenkins server on my home network
(Mr. Mime), using a CentOS 7 VM hosted on my home server. However, any
Jenkins setup should work for this project (including a &lt;a href=&#34;https://hub.docker.com/_/jenkins/&#34;&gt;docker
container&lt;/a&gt;). To get started, checkout the &lt;a href=&#34;https://jenkins.io/download/&#34;&gt;Jenkins
Website&lt;/a&gt;, and be sure to take advantage
of the &lt;a href=&#34;https://jenkins.io/doc/&#34;&gt;the documentation&lt;/a&gt; for help.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: just make sure hugo is installed on the Jenkins server, as we need
it to generate the website.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;github-integration&#34;&gt;GitHub Integration&lt;/h3&gt;

&lt;h4 id=&#34;jenkins-service&#34;&gt;Jenkins Service&lt;/h4&gt;

&lt;p&gt;My website repo is hosted on GitHub, so we need to configure it to
work with our Jenkins server. To do that, go to the project&amp;rsquo;s GitHub
page, and navigate through &lt;strong&gt;Settings&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Integrations &amp;amp;
services&lt;/strong&gt;. Click the &lt;strong&gt;Add service&lt;/strong&gt; drop-down and select &lt;em&gt;Jenkins
(Git Plugin)&lt;/em&gt;. Next, add the Jenkins server url (assuming the server
is accessible from the internet. If not, hosting the Jenkins server on
something like &lt;a href=&#34;http://digitalocean.com&#34;&gt;Digital Ocean&lt;/a&gt; might be an
easy solution). Lastly, make sure the &lt;strong&gt;Activate&lt;/strong&gt; box is selected,
and click the &lt;strong&gt;Add Service&lt;/strong&gt; button.&lt;/p&gt;

&lt;h4 id=&#34;ssh-keys&#34;&gt;SSH Keys&lt;/h4&gt;

&lt;p&gt;While on the project&amp;rsquo;s GitHub page, make sure that the Jenkins
server&amp;rsquo;s ssh keys are added to the project. To add them, navigate to
the &lt;strong&gt;Deploy Keys&lt;/strong&gt; page (under the project&amp;rsquo;s &lt;strong&gt;Settings&lt;/strong&gt; tab). Then
select &lt;strong&gt;Add deploy key&lt;/strong&gt;, and add the public key.&lt;/p&gt;

&lt;h2 id=&#34;a-nginx-server&#34;&gt;A Nginx Server&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;../../img/posts/draft-website-jenkins/nginx.png&#34;&gt;&lt;img
src=&#34;../../img/posts/draft-website-jenkins/nginx.png&#34; style=&#34;max-width:
100%; float: center; margin: 0px 0px 0px 0px;&#34; alt=&#34;Default Nginx Page&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With Jenkins ready, let&amp;rsquo;s quickly setup the web server before
configuring the Jenkins project. Any web server will do (it just needs
to serve the generated &lt;em&gt;static&lt;/em&gt; website content). I used
&lt;a href=&#34;https://nginx.org/en/&#34;&gt;nginx&lt;/a&gt; in for setup. After installing, make
sure it is running. To install and check the status of nginx on an
Ubuntu System:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## Install&lt;/span&gt;
sudo apt install -y nginx

&lt;span style=&#34;color:#75715e&#34;&gt;## Check it is running&lt;/span&gt;
sudo systemctl status nginx

&lt;span style=&#34;color:#75715e&#34;&gt;## Optional: Ensure it is enabled to start up after reboots&lt;/span&gt;
sudo systemctl enable nginx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the web server running, we need to know &lt;em&gt;where&lt;/em&gt; the website files
need to go. Nginx will by default serve content at
&lt;code&gt;/user/share/nginx/html/&lt;/code&gt;, so remember that location for later&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Don&amp;rsquo;t forget to add the &lt;code&gt;jenkins&lt;/code&gt; user&amp;rsquo;s ssh key from the
jenkins server to the &lt;code&gt;authorized_keys&lt;/code&gt; file of the nginx server. This
will make file transfers easier when setting up the jenkins project.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-a-project&#34;&gt;Configuring a Project&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s configure our Jenkins project! Log in to the Jenkins
server and click the &lt;strong&gt;New Item&lt;/strong&gt; option on the left side bar. Enter a
name for the project, select the &lt;strong&gt;Freestyle Project&lt;/strong&gt; option, and hit
&lt;strong&gt;OK&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../../img/posts/draft-website-jenkins/general-config.png&#34;&gt;&lt;img
src=&#34;../../img/posts/draft-website-jenkins/general-config.png&#34; style=&#34;max-width:
100%; float: center; margin: 0px 0px 0px 0px;&#34; alt=&#34;The Project&#39;s General Configuration Section&#34; /&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The Project&amp;rsquo;s General Configuration Section&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;General&lt;/strong&gt; section of the configuration screen, optionally
write a description about the project. Next, select the &amp;ldquo;&lt;em&gt;GitHub
Project&lt;/em&gt;&amp;rdquo; check-box, and add the GitHub repo&amp;rsquo;s url into the &lt;em&gt;Project
url&lt;/em&gt; text box.&lt;/p&gt;

&lt;h4 id=&#34;source-control&#34;&gt;Source Control&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;../../img/posts/draft-website-jenkins/credentials.png&#34;&gt;&lt;img
src=&#34;../../img/posts/draft-website-jenkins/credentials.png&#34;
style=&#34;max-width: 100%; float: center; margin: 0px 0px 0px 0px;&#34;
alt=&#34;Setting Credentials&#34; /&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Setting Credentials&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;Source Code Management&lt;/strong&gt; section of the configuration, select
the &lt;em&gt;Git&lt;/em&gt; option. Then, enter the repo&amp;rsquo;s url for the &lt;em&gt;Repository URL&lt;/em&gt;
box (I did the ssh url). For &lt;em&gt;Credentials&lt;/em&gt;, select &lt;em&gt;Add&lt;/em&gt; to configure a
new credential. Select &lt;em&gt;SSH Username with private key&lt;/em&gt; for &lt;em&gt;Kind&lt;/em&gt;,
use &lt;code&gt;jenkins&lt;/code&gt; for the &lt;em&gt;Username&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;More source control options can be configured, but this should be the
minimum setup required. &lt;em&gt;Again, for this to work public keys for the
&lt;code&gt;jenkins&lt;/code&gt; user on the jenkins server must be generated, and added as a
deployment key on GitHub.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;build-trigger&#34;&gt;Build Trigger&lt;/h4&gt;

&lt;p&gt;Under the &lt;strong&gt;Build Triggers&lt;/strong&gt; section, select &lt;em&gt;Poll SCM&lt;/em&gt;. Without
adding any schedule parameters, it will trigger each time a new commit
is detected. This is what we want.&lt;/p&gt;

&lt;h4 id=&#34;build-step&#34;&gt;Build Step&lt;/h4&gt;

&lt;p&gt;In the &lt;strong&gt;Build&lt;/strong&gt; section, click &lt;strong&gt;Add build step&lt;/strong&gt;, and select
&lt;strong&gt;Execute shell&lt;/strong&gt;. This is where we can add the shell commands to
build the website with hugo. Add the following command to the box
(don&amp;rsquo;t forget to change the url):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo -D -F -b &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://10.1.1.77&amp;#34;&lt;/span&gt; -d public&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;-D&lt;/code&gt; flag tells hugo to include all draft posts, while the &lt;code&gt;-F&lt;/code&gt; flag
has it include all posts with a future date. The &lt;code&gt;-b&lt;/code&gt; flag sets the
url for the generated website. This should the be url or IP address of
the nginx server setup previously. Lastly, the &lt;code&gt;-d&lt;/code&gt; flag tells hugo to
output the generated static website to the &lt;code&gt;public&lt;/code&gt; directory. This
will be useful to know when deploying the build.&lt;/p&gt;

&lt;h4 id=&#34;deploy-to-webserver&#34;&gt;Deploy to Webserver&lt;/h4&gt;

&lt;p&gt;For deployment, I used rsync to copy the build files to the nginx
web server. This step will be another shell command, so I&amp;rsquo;ve actually
added it as another &amp;ldquo;build&amp;rdquo; step. Add another &lt;strong&gt;Execute shell&lt;/strong&gt; and
paste the following command inside the text box (again, changing the url):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;rsync -r &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$WORKSPACE&lt;span style=&#34;color:#e6db74&#34;&gt;/public/&amp;#34;&lt;/span&gt; ryan@10.1.1.77:/usr/share/nginx/html/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I used the Jenkins &lt;code&gt;$WORKSPACE&lt;/code&gt; variable to get the location of the
build, and was able to append the &lt;code&gt;public&lt;/code&gt; directory to that, since we
defined it with the &lt;code&gt;-d&lt;/code&gt; flag in the hugo build step above. This will
copy the generated website, to the web server.&lt;/p&gt;

&lt;p&gt;Hit &lt;strong&gt;Save&lt;/strong&gt;, and test it out by clicking the &lt;strong&gt;Build Now&lt;/strong&gt; link on the
left. If the build is successful, check the nginx website to see if
the website was deployed!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: If it doesn&amp;rsquo;t work, double check all permissions and
credentials between accounts and servers.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;better-yet-pipelines&#34;&gt;Better Yet&amp;hellip; Pipelines&lt;/h2&gt;

&lt;p&gt;What&amp;rsquo;s better than using Jenkins for automated &amp;ldquo;draft website&amp;rdquo;
deployments?  Using a &lt;a href=&#34;https://jenkins.io/doc/book/pipeline/&#34;&gt;Jenkins
Pipeline&lt;/a&gt;. A Pipeline allows
the jenkins project steps to be defined in a &lt;em&gt;Jenkinsfile&lt;/em&gt; that, among
other benefits, can be source controlled. In fact, by default a
Jenkins pipeline searches for the &lt;code&gt;Jenkinsfile&lt;/code&gt; right in the root
directory of a project&amp;rsquo;s git repo.&lt;/p&gt;

&lt;p&gt;While a pipeline and
&lt;a href=&#34;https://jenkins.io/doc/book/pipeline/jenkinsfile/&#34;&gt;Jenkinsfile&lt;/a&gt; might
be a bit more confusing to &lt;em&gt;learn&lt;/em&gt; how to setup, it is well worth it. For
example, the following Jenkinsfile can be used to do essentially what
we setup in the previous steps:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
	label &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mr-mime&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
	stage &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
	    steps&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
		sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hugo -D -F -b &amp;#34;http://10.1.1.77&amp;#34;&amp;#39;&lt;/span&gt;
	    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
	stage &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;deploy&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
	    steps&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
		sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rsync -r &amp;#34;$WORKSPACE/public/&amp;#34; ryan@ponyta:/usr/share/nginx/html/&amp;#39;&lt;/span&gt;
	    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I&amp;rsquo;m not going to cover pipelines in &lt;em&gt;this&lt;/em&gt; post. However, I do
encourage readers to check them out.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s it. While I currently host my website using &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub
pages&lt;/a&gt;, if I ever self-host it again, I
will definitely automate publishing it using Jenkins as well. This has
been a &lt;em&gt;very&lt;/em&gt; basic example of what Jenkins can be used for, but I
have found it rather useful when working on the content of this
website. There is so much more it can do. Have fun!&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
