<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on λ ryan. himmelwright. net</title>
    <link>http://ryan.himmelwright.net/tags/python/</link>
    <description>Recent content in python on λ ryan. himmelwright. net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Feb 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://ryan.himmelwright.net/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Creating Tests For This Website: CI</title>
      <link>http://ryan.himmelwright.net/post/creating-website-tests-ci/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/creating-website-tests-ci/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;../../post/creating-website-tests-pages/&#34;&gt;last post&lt;/a&gt;, I setup some simple
testing for my website builds to that ensure that pages were being served
correctly.  However, I can&amp;rsquo;t trust myself to always manually run the tests
before merging a branch into &lt;code&gt;master&lt;/code&gt;. Luckily, I have
&lt;a href=&#34;https://jenkins.io&#34;&gt;Jenkins&lt;/a&gt; to take care of all the &amp;ldquo;&lt;em&gt;responsible&lt;/em&gt;&amp;rdquo; tasks. In
this post, we will take the test framework created in the previous post&amp;hellip;  and
automate it.&lt;/p&gt;

&lt;h2 id=&#34;what-i-m-using-plan&#34;&gt;What I&amp;rsquo;m Using/Plan&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/jenkins-logo.png&#34;&gt;
&lt;img alt=&#34;Jenkins Logo&#34; src=&#34;../../img/posts/creating-website-tests-ci/jenkins-logo.png&#34; style=&#34;float: right; max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;I have started using &lt;a href=&#34;https://gitlab.com&#34;&gt;Gitlab&lt;/a&gt; for more of my projects
recently, but have decided to keep my website source hosted on Github for the time
being. So, I won&amp;rsquo;t be using Gitlab&amp;rsquo;s CI/CD tools for &lt;em&gt;this&lt;/em&gt;, but I wanted it
to be known that this automation is &lt;em&gt;very&lt;/em&gt; straight forward and could be easily
accomplished there as well.&lt;/p&gt;

&lt;p&gt;For this project, because my website is hosted on Github, and I &lt;em&gt;already&lt;/em&gt;
have &lt;a href=&#34;../../post/extending-vm-hd/&#34;&gt;my own Jenkins server&lt;/a&gt; configured&amp;hellip; I will be
using a Jenkins pipeline. First, we will create the pipeline file to add
to the git repo. Then, we will use the pipeline to configure a new
&lt;em&gt;multi-branch&lt;/em&gt; pipeline in Jenkins.&lt;/p&gt;

&lt;h2 id=&#34;jenkinsfile&#34;&gt;Jenkinsfile&lt;/h2&gt;

&lt;p&gt;Lets start by creating the Jenkinsfile. Create a new file named &lt;code&gt;Jenkinsfile&lt;/code&gt;
in the project directory. Next, lets create a new pipeline and get ready to add
stages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    agent any

    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// This is where the stages will be defined //
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;(Make sure to add the closing &lt;code&gt;}&lt;/code&gt;&amp;rsquo;s!)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;stages&#34;&gt;Stages&lt;/h3&gt;

&lt;p&gt;Now, lets add the stages. A stage is a named, functional chunk in our pipeline.
Breaking the pipeline into stages will help keep all the various steps
organized, as well as make it easier to follow along as the pipeline runs.&lt;/p&gt;

&lt;p&gt;Each of the following stage definitions will be placed inside the &lt;code&gt;stages { ..
}&lt;/code&gt; section we defined above (&lt;em&gt;in the same order as they are listed!&lt;/em&gt;).&lt;/p&gt;

&lt;h4 id=&#34;setup-deps&#34;&gt;Setup Deps&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Setup Deps&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum update -y&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum install -y epel-release&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sudo yum install -y hugo python36-pytest&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first stage is &amp;lsquo;Setup Deps&amp;rsquo;. This stage handles installing any dependencies
our Jenkins node will need installed to run the tests. Our tests will require
&lt;code&gt;hugo&lt;/code&gt;, &lt;code&gt;pytest&lt;/code&gt;, and &lt;code&gt;python3&lt;/code&gt;. It will also require some &lt;code&gt;pip&lt;/code&gt; packages, but
we will get to that later.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: My current Jenkins node is running CentOS, so my package manager commands
are specific to that. As always, adjust accordingly.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;start-hugo-server&#34;&gt;Start Hugo Server&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Start Hugo Server&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hugo serve &amp;amp;&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;hugo&lt;/code&gt; installed (and presumably being inside the website&amp;rsquo;s git repo&amp;hellip;),
we can start the web server. This is done with &lt;code&gt;hugo serve&lt;/code&gt;. The &lt;code&gt;&amp;amp;&lt;/code&gt; is used to
have the server run as a background process so that it won&amp;rsquo;t be killed when the
pipeline to continues on.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Make sure the tests are set to point to &lt;code&gt;localhost:1313&lt;/code&gt;, as that is
where &lt;code&gt;hugo&lt;/code&gt; will try to serve the website by default.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;setup-python&#34;&gt;Setup Python&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Setup Tests&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pip3 install pipenv --user&amp;#39;&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;python3 -m pipenv install&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, lets configure &lt;code&gt;python&lt;/code&gt; by setting up an environment and installing the
packages we need in it. First, I use &lt;code&gt;pip3&lt;/code&gt; to install &lt;code&gt;pipenv&lt;/code&gt;. Then, I have
&lt;code&gt;pipenv&lt;/code&gt; install the tests&amp;rsquo; required python packages, which are defined in the
repo&amp;rsquo;s &lt;code&gt;Pipfile&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;run-tests&#34;&gt;Run Tests&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Run Tests&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            set +e
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            python3 -m pipenv run pytest -v --junit-xml himmallright-source-test-report.xml .
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            set -e
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stripIndent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Test time. I again utilize &lt;code&gt;pipenv&lt;/code&gt; here, by having it call the test command
(&lt;code&gt;pytest -v --junit-xml himmallright-source-test-report.xml .&lt;/code&gt;) so that it runs
in the pipenv virtual environment.&lt;/p&gt;

&lt;p&gt;Two things to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;--junit-xml&lt;/code&gt; flag defines a xml filename to write the junit test report
to. This will be used by Jenkins to collect the test results.&lt;/li&gt;
&lt;li&gt;The test command is wrapped between &lt;code&gt;set +e&lt;/code&gt; and &lt;code&gt;set -e&lt;/code&gt; commands, which
allows tests to fail but without triggering a &lt;em&gt;pipeline&lt;/em&gt; failure in
Jenkins.  This way even if tests fail, we make it all the way through
collection so we can see &lt;em&gt;what&lt;/em&gt; tests failed and &lt;em&gt;why&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;collect-test-results&#34;&gt;Collect Test Results&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Collect Test Resuts&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        archiveArtifacts &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;himmallright-source-test-report.xml&amp;#34;&lt;/span&gt;
        junit &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;himmallright-source-test-report.xml&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, we archive the junit report xml file as a Jenkins artifact (just in
case). Finally, we have the &lt;a href=&#34;https://plugins.jenkins.io/junit/&#34;&gt;junit&lt;/a&gt; plugin
collect the report.&lt;/p&gt;

&lt;h3 id=&#34;save-commit&#34;&gt;Save &amp;amp; Commit&lt;/h3&gt;

&lt;p&gt;That should be it for the pipeline file! Commit and push it to the git repo,
and we can start working with it in Jenkins!&lt;/p&gt;

&lt;h2 id=&#34;multibranch-pipelines&#34;&gt;Multibranch Pipelines&lt;/h2&gt;

&lt;p&gt;With the &lt;code&gt;Jenkinsfile&lt;/code&gt; in the repo, we can create the pipeline! Specifically,
we will be creating a mult-branch pipeline. A &lt;em&gt;multi-branch&lt;/em&gt; job scans a git
project, and creates a separate pipeline for each branch or PR in the repo.
This is beneficial for testing, as it will automatically instantiate a test
pipeline against a newly created PR, so we can verify that the PR passes the
tests before merging it into the &lt;code&gt;master&lt;/code&gt; branch. Additionally, it lets us make
sure we aren&amp;rsquo;t breaking anything &lt;em&gt;while&lt;/em&gt; working in a new branch.&lt;/p&gt;

&lt;h4 id=&#34;creating-the-pipeline&#34;&gt;Creating the Pipeline&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/new-job.png&#34;&gt;
&lt;img alt=&#34;Creating a new Jenkins Item&#34; src=&#34;../../img/posts/creating-website-tests-ci/new-job.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Select Multibranch Pipeline from the new item menu in Jenkins.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To create a Multi-Branch pipeline, select &lt;em&gt;New Item&lt;/em&gt; in the menu on the left.
Next, enter a name for the pipeline and select &lt;em&gt;Multibranch Pipeline&lt;/em&gt; at the
bottom. Click &lt;em&gt;Ok&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;configuring-the-pipeline&#34;&gt;Configuring the Pipeline&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/multipipeline-config-options.png&#34;&gt;
&lt;img alt=&#34;Multibranch pipeline config options&#34; src=&#34;../../img/posts/creating-website-tests-ci/multipipeline-config-options.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Configuration options when creating the multibranch
pipeline.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;On the pipelines configuration page, start by filling out the &lt;em&gt;Display Name&lt;/em&gt;
and &lt;em&gt;Description&lt;/em&gt; text boxes. Next, go down to &lt;em&gt;Branch Sources&lt;/em&gt; and click on
&lt;em&gt;Add source&lt;/em&gt;. My website is currently hosted on Github, so I will select that.
However, select &lt;em&gt;Git&lt;/em&gt; if your project is hosted on another &lt;code&gt;git&lt;/code&gt; service.&lt;/p&gt;

&lt;p&gt;Add the Repository URL and choose the pipeline Behaviors. The Behaviors define
how the pipeline will split up branches. For example, it can be selected to
only discover branches that are also PRs.&lt;/p&gt;

&lt;p&gt;Next, in the &lt;em&gt;Build Configuration&lt;/em&gt; section, be sure that the &lt;em&gt;Script Path&lt;/em&gt;
defines the path where the &lt;code&gt;Jenkinsfile&lt;/code&gt; is located. If it&amp;rsquo;s in the root
directory (and named &lt;code&gt;Jenkinsfile&lt;/code&gt;), the default should work.&lt;/p&gt;

&lt;p&gt;Lastly, select an interval to automatically check the repo for changes in the
&lt;em&gt;Scan Repository Triggers&lt;/em&gt; section. This step is optional, but I highly
recommend it.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all we &lt;em&gt;need&lt;/em&gt; to setup, but feel free to research more options. I mostly
have defaults selected for the rest. When complete, hit &lt;em&gt;Save&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;running-pipelines&#34;&gt;Running Pipelines&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/multibranch-pipeline-overview.png&#34;&gt;
&lt;img alt=&#34;The multibranch pipeline overview page&#34; src=&#34;../../img/posts/creating-website-tests-ci/multibranch-pipeline-overview.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The multibranch pipeline overview page.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Once the multibranch pipeline is created, it should scan the repo to detect any
branches or pull requests that have defined &lt;code&gt;Jenkinsfile&lt;/code&gt;s. It will create an
job item in the list for each branch/PR it detects (and kick off runs for
each).&lt;/p&gt;

&lt;p&gt;To manually start a scan, select &lt;em&gt;Scan Repository Now&lt;/em&gt; in the menu on the left,
and it will scan all the branches again, looking for changes, and kicking off
pipeline runs for any branch or pr that has changed.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/branch-overview.png&#34;&gt;
&lt;img alt=&#34;The overview page of a single branch&#34; src=&#34;../../img/posts/creating-website-tests-ci/branch-overview.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The overview page of a single branch.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To manually start a specific branch run, click on the branch name to enter the
branch&amp;rsquo;s job overview page. Then, simply click &lt;em&gt;Build Now&lt;/em&gt; on the left. Once
the run starts, it runs like a normal jenkins job and can be viewed by clicking
the job&amp;rsquo;s run number to the bottom left. The job&amp;rsquo;s progress can then be viewed
on that page, or using &lt;em&gt;Blue Ocean&lt;/em&gt; (Recommended).&lt;/p&gt;

&lt;h2 id=&#34;viewing-results&#34;&gt;Viewing Results&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-ci/test-results.png&#34;&gt;
&lt;img alt=&#34;The overview page of a single branch&#34; src=&#34;../../img/posts/creating-website-tests-ci/test-results.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;The overview page of a single branch.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Personally, I prefer to always view the test results using the Blue Ocean
viewer. Once a job completes, select the &lt;em&gt;Tests&lt;/em&gt; tab at the top of the viewer
to see the collected test results (this is what the junit steps in our pipeline
does). If all the tests passed, the page will be green and list all the
completed tests. If some failed, it will be yellow. When there are failed
tests, they can be clicked, and the row will expand to show the failed test&amp;rsquo;s
error message and stack trace. For my test set, this makes it easy to see which
page failed, and even know what status code was &lt;em&gt;actually&lt;/em&gt; returned in the
response (by looking at the stack trace). Very helpful!&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There we go! Not only do we now have the website tests automated as a pipeline,
but as a &lt;em&gt;multibranch&lt;/em&gt; pipeline. This should help automatically ensure that
nothing breaks as I edit and add to the website. It will even run the tests
against all my PRs, so I can be confident that when I merge to master, it won&amp;rsquo;t
slowly degrade my website over time. I have one more post about these tests
planned, but in the meantime&amp;hellip; enjoy Jenkins!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating Tests For This Website: Pages</title>
      <link>http://ryan.himmelwright.net/post/creating-website-tests-pages/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/creating-website-tests-pages/</guid>
      <description>&lt;p&gt;As this website grows, there is an increasing amount of complexity. More posts,
more images, and more links. I&amp;rsquo;ve gotten better at breaking work up into
separate branches (instead of pushing everything straight to &lt;code&gt;master&lt;/code&gt;), but
even that isn&amp;rsquo;t enough to ensure everything works as expected when publishing
something new. Then, I thought of something obvious&amp;hellip; I could setup some
simple testing&amp;hellip; for my website.&lt;/p&gt;

&lt;h2 id=&#34;what-to-test&#34;&gt;What to Test&lt;/h2&gt;

&lt;p&gt;After editing a page or drafting a new post, I often wonder &amp;ldquo;how can I be
&lt;em&gt;sure&lt;/em&gt; everything will still work when I publish this change&amp;rdquo;? I question if
every post file is &lt;em&gt;actually&lt;/em&gt; being served as a web page. Or worse&amp;hellip; I fear
that a post that isn&amp;rsquo;t &lt;em&gt;ready&lt;/em&gt; to be published might &lt;em&gt;accidentally&lt;/em&gt; get pushed
with an unrelated website fix.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Yes, this is a completely unreasonable fear given that ALL of my
website source files, drafts included, are publicly hosted on Github.
Nonetheless, the fear exists)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This will be a multi-post serries, so in this first one we will focus on:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuring the test environment&lt;/li&gt;
&lt;li&gt;Building up the testing framework&lt;/li&gt;
&lt;li&gt;Writing some basic tests to ensure:

&lt;ul&gt;
&lt;li&gt;The pages I &lt;em&gt;want&lt;/em&gt; to be served are&lt;/li&gt;
&lt;li&gt;Pages and posts that are not ready, are &lt;em&gt;not&lt;/em&gt; being served&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As my website is currently compiled using &lt;a href=&#34;https://gohugo.io&#34;&gt;hugo&lt;/a&gt;, the tests
will be centered around that framework. However, most of the information can be
applied to testing websites using other static website generators, are they are
all quite similar.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-the-env&#34;&gt;Setting up the env&lt;/h2&gt;

&lt;p&gt;I will be using
&lt;a href=&#34;https://docs.pytest.org/en/latest/contents.html&#34;&gt;pytest&lt;/a&gt; for the testing
framework, and to make all the
python dependencies a bit easier to manage, I will also use
&lt;a href=&#34;https://github.com/pypa/pipenv&#34;&gt;pipenv&lt;/a&gt;. Lastly, I usually work on a
&lt;a href=&#34;https://getfedora.org&#34;&gt;Fedora&lt;/a&gt; computer, VM, or at the very least in a Fedora
&lt;a href=&#34;https://podman.io&#34;&gt;podman&lt;/a&gt; container. So, some of my instructions use &lt;code&gt;dnf&lt;/code&gt;,
but feel free to adjust to your package manager accordingly.&lt;/p&gt;

&lt;h4 id=&#34;install-pipenv&#34;&gt;Install &lt;code&gt;pipenv&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;First, lets install &lt;code&gt;pipenv&lt;/code&gt;, which is easy enough in Fedora:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo dnf install pipenv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;install-needed-packages-inside-pipenv-shell&#34;&gt;Install needed packages inside &lt;code&gt;pipenv shell&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;After installing, create a pipenv shell and enter it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pipenv shell&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install &lt;code&gt;pytest&lt;/code&gt; and &lt;code&gt;requests&lt;/code&gt; in the pip environment:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pip install pytest requests&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;creating-the-test-framework&#34;&gt;Creating the Test Framework&lt;/h2&gt;

&lt;p&gt;With the environment setup, we can start building up the test framework. We
will start by defining come constants, then use those when building helper
functions. Lastly, we will use the helper functions to piece together the
&lt;code&gt;conftest.py&lt;/code&gt; and &lt;code&gt;test_pages.py&lt;/code&gt; files.&lt;/p&gt;

&lt;h3 id=&#34;defining-constants&#34;&gt;Defining Constants&lt;/h3&gt;

&lt;p&gt;First, lets define some constants we can use throughout the test framework. In
the future, I might switch these to be set optionally with  CLI arguments, but
for now&amp;hellip; they&amp;rsquo;re just static constant variables defined in a file.&lt;/p&gt;

&lt;p&gt;So first, create a new file in the &lt;code&gt;tests&lt;/code&gt; directory named &lt;code&gt;constants.py&lt;/code&gt;. In
that file, lets dump our contants:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;BASE_URL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:1313&amp;#34;&lt;/span&gt;

SITE_PAGES &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pages/about/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/pages/homelab/&amp;#34;&lt;/span&gt;]

POST_DIR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./content/post/&amp;#34;&lt;/span&gt;
POST_NAMES &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;25-days-of-c&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Removed middle of list because it&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s long&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ZFS-Backups-To-LUKS-External&amp;#34;&lt;/span&gt;,
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, in my &lt;code&gt;constants.py&lt;/code&gt; file I have 4 variables defined:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BASE_URL&lt;/code&gt;: this is the base url for the website when running &lt;code&gt;hugo serve&lt;/code&gt;.
For most, it will default to &lt;code&gt;http://localhost:1313&lt;/code&gt;, but I have this as
a constant because I usually run my &lt;code&gt;hugo serve&lt;/code&gt; command with the &lt;code&gt;-b&lt;/code&gt; to
change it to an ip address so I can view it from other computers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SITE_PAGES&lt;/code&gt;: This is a list of paths that come &lt;em&gt;after&lt;/em&gt; the baseurl for pages that
we well be testing. For example, I want to make sure that my &amp;ldquo;about me&amp;rdquo;
page is being served, which is at &lt;code&gt;baseurl/pages/about/&lt;/code&gt;, so
&lt;code&gt;/pages/about/&lt;/code&gt; is one of the values in this constant.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST_DIR&lt;/code&gt;: This is the directory for where the post &lt;em&gt;files&lt;/em&gt; are located.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST_NAMES&lt;/code&gt;: This is a list of the names of the post &lt;em&gt;files&lt;/em&gt; (without the
&lt;code&gt;.md&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Add in your values for the variables, and remember to save the file.&lt;/p&gt;

&lt;h3 id=&#34;writing-some-helper-utility-functions&#34;&gt;Writing Some Helper Utility Functions&lt;/h3&gt;

&lt;p&gt;With those constants defined, we should be ready to write some helper
functions. These are normal python functions that will be called from tests or
even test fixture functions.&lt;/p&gt;

&lt;p&gt;First, lets create &lt;code&gt;utils.py&lt;/code&gt;. The helper functions will need to use
&lt;code&gt;listdir&lt;/code&gt;, as well as the &lt;code&gt;path&lt;/code&gt; function from the &lt;code&gt;os&lt;/code&gt; module. They will also
need the regex functions. So, lets make those imports at the top of the file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; os &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; listdir, path
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; re&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;get-file-names&#34;&gt;get_file_names&lt;/h4&gt;

&lt;p&gt;Lets define a helper function named &lt;code&gt;get_file_names&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_file_names&lt;/span&gt;(src, extension&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;None):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Collects the names of all files of a directory&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    file_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    root_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;expanduser(src)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; file &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; listdir(root_path):
        &lt;span style=&#34;color:#75715e&#34;&gt;# If extension provided, check file has that extension&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; extension:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; file&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;endswith(extension):
                file_list&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(file)
        &lt;span style=&#34;color:#75715e&#34;&gt;# Otherwise, add everything&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            file_list&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(file)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; file_list&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When provided a file path (&lt;code&gt;src&lt;/code&gt;), this function will return a list of all the
file names in the directory. Optionally, the &lt;code&gt;extension&lt;/code&gt; parameter can be
supplied to only return files of that extension type (for exapmple, &lt;code&gt;md&lt;/code&gt;). This
function will be used to grab the names of all the post source files.&lt;/p&gt;

&lt;p&gt;&amp;hellip; and that&amp;rsquo;s all we need in &lt;code&gt;utils.py&lt;/code&gt;&amp;hellip; for now!&lt;/p&gt;

&lt;h3 id=&#34;conftest&#34;&gt;Conftest&lt;/h3&gt;

&lt;p&gt;Now lets start digging into test-related stuff, by first creating a
&lt;code&gt;conftest.py&lt;/code&gt; file. This file will mostly hold the fixtures we will use for the
tests. In our particular setup, they will gather lists of pages to run multiple
calls of each test against by using &lt;code&gt;@pytest.fixture(params)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But first, lets import a few things at the top of &lt;code&gt;conftest.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pytest
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; os &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; path

&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; constants &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; BASE_URL, SITE_PAGES, POST_DIR, POST_NAMES
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; utils &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; get_file_names&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The imports include the &lt;code&gt;os.path()&lt;/code&gt; function, some of the constants we
defined, and the &lt;code&gt;get_file_names()&lt;/code&gt; helper function. Oh, And of course
&lt;code&gt;pytest&lt;/code&gt; ;) .&lt;/p&gt;

&lt;h4 id=&#34;page-url&#34;&gt;page_url&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.fixture&lt;/span&gt;(params&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;SITE_PAGES)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;page_url&lt;/span&gt;(request):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Returns the page urls for testing.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; BASE_URL &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;param&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first fixture, &lt;code&gt;page_url&lt;/code&gt;, is very basic. It creates a list of all of the
website pages (not posts), by combining the &lt;code&gt;BASE_URL&lt;/code&gt; with each of the values
defined in the &lt;code&gt;SITE_PAGES&lt;/code&gt; constant. This list will later be used to
paramaterize a single test across all of the page links.&lt;/p&gt;

&lt;h4 id=&#34;post-url&#34;&gt;post_url&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.fixture&lt;/span&gt;(params&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;POST_NAMES)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_url&lt;/span&gt;(request):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Returns the post urls for testing.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; BASE_URL &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/post/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;param&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lower()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next fixture, &lt;code&gt;post_url&lt;/code&gt; is basically the same as &lt;code&gt;page_url&lt;/code&gt;, except it
creates a list of all the &lt;em&gt;posts&lt;/em&gt; using the &lt;code&gt;POST_NAMES&lt;/code&gt; constant. Again, this
will be used to expand a single test into many, one for each post.&lt;/p&gt;

&lt;h4 id=&#34;non-live-post-url&#34;&gt;non_live_post_url&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.fixture&lt;/span&gt;(params&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;non_live_post_urls())
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;non_live_post_url&lt;/span&gt;(request):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Returns the url of a non-defined post file&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; BASE_URL &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/post/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;param&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lower()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lastly, we have &lt;code&gt;non_live_post_url&lt;/code&gt; with its accompanying helper function,
&lt;code&gt;non_live_post_urls&lt;/code&gt;. This pair creates a list of posts that have a markdown
file in the &lt;code&gt;/post/&lt;/code&gt; directory, but are &lt;em&gt;not&lt;/em&gt; listed in the &lt;code&gt;POST_NAMES&lt;/code&gt;
constant (so in practice, not really to be published).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;non_live_post_urls&lt;/span&gt;():
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Returns the urls of md files that should not be live.&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    all_post_md_names &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(
        map(&lt;span style=&#34;color:#66d9ef&#34;&gt;lambda&lt;/span&gt; name: name&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lower()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.md&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], get_file_names(POST_DIR))
    )
    live_post_names &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(&lt;span style=&#34;color:#66d9ef&#34;&gt;lambda&lt;/span&gt; name: name&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lower(), POST_NAMES))
    non_live_post_names &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(all_post_md_names)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;difference(set(live_post_names))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; list(non_live_post_names)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, the &lt;code&gt;non_live_post_urls&lt;/code&gt; helper function returns a list of non-listed
post files. That  list is then used in &lt;code&gt;non_live_post_url&lt;/code&gt; as the
&lt;code&gt;pytest.fixture(params)&lt;/code&gt; object, much like &lt;code&gt;SITE_PAGES&lt;/code&gt; and &lt;code&gt;POST_NAMES&lt;/code&gt; were
for the previous
fixtures.&lt;/p&gt;

&lt;h3 id=&#34;finally-some-tests&#34;&gt;Finally&amp;hellip; Some Tests!&lt;/h3&gt;

&lt;p&gt;Phew. Okay. With &lt;em&gt;all of that&lt;/em&gt; defined&amp;hellip; lets create the first test file. When
&lt;code&gt;pytest&lt;/code&gt; runs, it will try to grab tests recursively from all the files down
the current directory, starting with &lt;code&gt;test&lt;/code&gt;. This first set of tests will be
checking whether a web page is being served (or not), so lets name the file
&lt;code&gt;test_pages.py&lt;/code&gt;. Again, start with the required imports. This time we only need
&lt;code&gt;pytest&lt;/code&gt; and &lt;code&gt;requests&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pytest
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; requests&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&#34;testing-pages&#34;&gt;Testing Pages&lt;/h5&gt;

&lt;p&gt;The first test will check that each page defined in the &lt;code&gt;SITE_PAGES&lt;/code&gt; constant
is being served. More specifically, we will use the &lt;code&gt;requests&lt;/code&gt; module to ensure
not only that the page is served, but returns a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200&#34;&gt;200
status&lt;/a&gt;. This
actually requires very little code to accomplish (Gotta love python) :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_page_served&lt;/span&gt;(page_url):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Checks that the website pages are available&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(page_url)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We simply define a function, &lt;code&gt;test_page_served()&lt;/code&gt;, and because it is in
&lt;code&gt;test_pages.py&lt;/code&gt;, it will be assumed to be a test by &lt;code&gt;pytest&lt;/code&gt;. We provide the
&lt;code&gt;page_url&lt;/code&gt; fixture we previously defined in &lt;code&gt;conftest.py&lt;/code&gt; as the only
parameter. This will call the &lt;code&gt;test_page_served&lt;/code&gt; test for each url
in the list generated by &lt;code&gt;page_url&lt;/code&gt;. Next, we use &lt;code&gt;requests.get()&lt;/code&gt; to make a
page request. Lastly, we &lt;code&gt;assert&lt;/code&gt; that the &lt;code&gt;status_code&lt;/code&gt; from our response is
&lt;code&gt;200&lt;/code&gt;. If it is, the test passes, if not, it fails.&lt;/p&gt;

&lt;h5 id=&#34;testing-posts&#34;&gt;Testing Posts&lt;/h5&gt;

&lt;p&gt;Next, lets test that all of the &lt;em&gt;posts&lt;/em&gt; are being served. This test works
&lt;em&gt;exactly&lt;/em&gt; the same as &lt;em&gt;test_page_served&lt;/em&gt;, except we are using the &lt;code&gt;post_url&lt;/code&gt;
fixture instead of &lt;code&gt;page_url&lt;/code&gt; to supply the links to test:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_post_served&lt;/span&gt;(post_url):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Checks that the desired posts are available&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(post_url)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;(While I could combine these cases into a single test function, I decided to
keep them separate for flexibility in the future)&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;lets-get-fancy-testing-unapproved-posts-are-not-served&#34;&gt;Lets Get Fancy: Testing Unapproved Posts Are &lt;em&gt;NOT&lt;/em&gt; Served&lt;/h5&gt;

&lt;p&gt;For the last test, lets get a little bit more complicated and ensure that post files
&lt;em&gt;not&lt;/em&gt; listed in the approved list are &lt;em&gt;not&lt;/em&gt; being served. Well&amp;hellip; it
turns out all the &amp;ldquo;fancy&amp;rdquo; code required for this test case already occured in
the &lt;code&gt;non_live_post_urls&lt;/code&gt; helper function. The &lt;em&gt;test&lt;/em&gt; function itself, is
essentially the same as what we&amp;rsquo;ve already encountered &lt;em&gt;except&lt;/em&gt; that we are
now checking for a &lt;code&gt;404&lt;/code&gt; return status instead of &lt;code&gt;200&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_non_defined_posts_not_served&lt;/span&gt;(non_live_post_url):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Checks that a non-defined post is NOT available&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(non_live_post_url)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;404&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That defines all of the tests for this first set! Don&amp;rsquo;t let only having three
test functions fool you, they should generate over 70 test results when run!
(For my website, at the time of writing this post)&lt;/p&gt;

&lt;h3 id=&#34;lets-run-some-tests&#34;&gt;Lets Run Some Tests!&lt;/h3&gt;

&lt;p&gt;Finally, we should be able to run the tests. To do so, first ensure that you
are in the pipenv by running &lt;code&gt;pipenv shell&lt;/code&gt;, &lt;em&gt;or&lt;/em&gt; you can run the tests from
outside the pipenv using &lt;code&gt;pipenv run COMMAND&lt;/code&gt;. Next, call:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;pytest -v .&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;-v&lt;/code&gt; flag runs pytest in &lt;em&gt;&amp;lsquo;verbose&amp;rsquo;&lt;/em&gt; mode, which I like to do as it shows
the results for each test run, rather than each &lt;em&gt;file&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;video style=&#34;max-width:100%;&#34; controls&gt;
  &lt;source src=&#34;../../img/posts/creating-website-tests-pages/passing-tests.mp4&#34; type=&#34;video/mp4&#34;&gt;
&lt;/video&gt;
&lt;div id=&#34;caption&#34;&gt;Running the pages tests. All 72 passed.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;So it looks like all the tests are passing! To be sure, Lets do a quick check to
make sure they work as expected&amp;hellip; I&amp;rsquo;ll mark this post with &lt;code&gt;draft = &amp;quot;False&amp;quot;&lt;/code&gt;,
but &lt;em&gt;not&lt;/em&gt; add it to the approved lists, and the test for this page &lt;em&gt;should&lt;/em&gt;
fail&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;../../img/posts/creating-website-tests-pages/failed-test.png&#34;&gt;
&lt;img alt=&#34;Checking a test fails when we want it to&#34; src=&#34;../../img/posts/creating-website-tests-pages/failed-test.png&#34; style=&#34;max-width: 100%; padding: 5px 15px 10px 10px&#34;/&gt;&lt;/a&gt;
&lt;div class=&#34;caption&#34;&gt;Checking that a test fails when we want it to.&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Awesome, it failed! I guess all there is left to do is to finish up this post, so I
can add it to the approved posts lists and publish it! Stay tuned!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LIA 1.0 Beta Released</title>
      <link>http://ryan.himmelwright.net/post/lia-1-0-beta-released/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ryan.himmelwright.net/post/lia-1-0-beta-released/</guid>
      <description>&lt;p&gt;I have released the 1.0 Beta version for a personal project of mine: the &lt;strong&gt;L&lt;/strong&gt;edger &lt;strong&gt;I&lt;/strong&gt;mport &lt;strong&gt;A&lt;/strong&gt;ssistant, or &lt;a href=&#34;https://github.com/himmALlRight/LIA/&#34;&gt;LIA&lt;/a&gt;. This post will talk briefly about the background of LIA, what it does, and explain the beta release.&lt;/p&gt;

&lt;h2 id=&#34;what-is-lia&#34;&gt;What is LIA?&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;Credit Card Statement CSV&#34; src=&#34;../../img/posts/LIA-1-0-Beta-Released/creditCardDownload.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example Cred Card Statement CSV File&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A while ago, I discovered &lt;a href=&#34;http://www.ledger-cli.org&#34;&gt;Ledger&lt;/a&gt;, the command line double-entry accounting application. Its powerful, yet simple design attracted me, and I wanted to try it out. To use it effectively however, I needed a method to import our bank and credit card statements into ledger journals. Then, I could use ledger to analyze the finances. However, there was an issue. While there are several great ledger convert/import options out there, many were more complicated than what I was looking for. So&amp;hellip;I wrote my own.&lt;/p&gt;

&lt;p&gt;&lt;img alt= &#34;Example Ledger Journal File&#34; src=&#34;../../img/posts/LIA-1-0-Beta-Released/ledger-journal.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example Ledger Journal File&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When I started writing LIA, I just wanted a python script that could help me convert the contents of a .csv file into a ledger-journal formatted file (without any of the fancy features. Just the basics). I thought it was a simple task and should only take me a few hours. It was, and it did. I wrote the the first basic implementation of LIA on a Sunday afternoon. While coding that bare-bones version, I realized that even though it &lt;em&gt;technically worked&lt;/em&gt;, it would not be enjoyable to use, and therefore I would never use it. So I decided to expand it into a full project, something more than a simple script.&lt;/p&gt;

&lt;h2 id=&#34;what-does-lia-do&#34;&gt;What does LIA do?&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;LIA Running&#34; src=&#34;../../img/posts/LIA-1-0-Beta-Released/LIA-demo.gif&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;LIA executes the core functionality that originally prompted me to write it: converting bank/credit card statement csv files into ledger journal files. Beyond that basic functionality,  LIA has a few nice features that help the user manually convert these files in an enjoyable way. By going through each transaction manually, the user has full control to make sure data is being input correctly. However, LIA helps make this otherwise dull process fast and efficient. Some of LIA&amp;rsquo;s features that help accomplish this are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data order is recognized by a header mechanism&lt;/li&gt;
&lt;li&gt;Prompts the user to potentially edit the transaction information&lt;/li&gt;
&lt;li&gt;Sets default transaction information from the values of the csv file&lt;/li&gt;
&lt;li&gt;Manual transaction entries when needed (No input file)&lt;/li&gt;
&lt;li&gt;Supports multiple destination accounts&lt;/li&gt;
&lt;li&gt;Automatic placement system. The user can specify a file containing rules to automatically place transactions. (ex: anything with &amp;ldquo;Dunkin&amp;rdquo; in the description will default to Expenses:Food:Coffee)&lt;/li&gt;
&lt;li&gt;Colored prompts&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-does-lia-1-0-beta-mean&#34;&gt;What does LIA 1.0 Beta mean?&lt;/h2&gt;

&lt;h3 id=&#34;lia-1-0&#34;&gt;LIA 1.0&lt;/h3&gt;

&lt;p&gt;&lt;img alt=&#34;My 1.0 Todo List&#34; src=&#34;../../img/posts/LIA-1-0-Beta-Released/release-todo.png&#34; style=&#34;max-width: 100%;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;My Todo list to release the 1.0 Version&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When I expanded LIA to a personal project, I recorded several features that would make converting CSV statements easier, and got started. I worked on the project here and there, adding each feature over time. These features are what I determined were required in order for the application to be acceptably &lt;em&gt;usable&lt;/em&gt;. When all of those requirements were met, I would release an official 1.0 Branch.&lt;/p&gt;

&lt;p&gt;The main functionality of LIA has been implemented for a while now. Being a python application, it has been possible to run LIA by calling the files with python. However, I didn&amp;rsquo;t want to release the 1.0 version without first making an installer. I wanted LIA to be run like a normal linux application. I have now finished configuring the project and a &lt;code&gt;setup.py&lt;/code&gt; file, so users can use python&amp;rsquo;s setuptools to install LIA as an application on their computer. Additionally, I have even packaged LIA as a Solus eopkg. It looks like I am ready for release.&lt;/p&gt;

&lt;h3 id=&#34;beta&#34;&gt;Beta&lt;/h3&gt;

&lt;p&gt;Sort of. Until now, I have been developing, but not using LIA day to day. I want to spend some time actually &lt;em&gt;using&lt;/em&gt; the application to see if there are any remaining issues. Also, I have not confirmed that it fully does what is needed for ledger. I want to get a few ledger users to quickly look at it and let me know if they see any issues. After testing it for a bit, I will release it as the official 1.0 release. This will mean it should be stable enough for people to use, if they so choose to.&lt;/p&gt;

&lt;h2 id=&#34;more-information&#34;&gt;More Information&lt;/h2&gt;

&lt;p&gt;To test out LIA, read some documentation, or find out more  &lt;a href=&#34;https://github.com/himmAllRight/lia/&#34;&gt;check it out&lt;/a&gt; on &lt;a href=&#34;https://github.com/himmAllRight&#34;&gt;my github page&lt;/a&gt;. I plan to continue to develop it further in the future. If you have a suggestion, or even some code you&amp;rsquo;d like to contribute, feel free to let me know, either on github or my &lt;a href=&#34;../../pages/about/&#34;&gt;other contact methods&lt;/a&gt;. Enjoy!&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
